<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui">
    <title>脱离引力</title>
    <style type="text/css">
      html,body{
        width: 100%;
        height:100%;
        overflow: hidden;
        margin:0;
        background:black;
      }
      #cover{
        width:320px;
        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
        margin:auto;
      }
      canvas{
        /*border:red solid 1px;*/
      }

    </style>
  </head>
  <body>
    <img id="cover" src="./img/face.png" alt="" />
    <canvas id="canvas"></canvas>
  </body>
  <script type="text/javascript">
    var canvas=document.getElementById("canvas");
    var context=canvas.getContext("2d");
    var cover=document.getElementById("cover");
    var winW=window.innerWidth;
    var winH=window.innerHeight;
    var count=5;//障碍物的数量
    var AllXY=[];//用来存储所有障碍物的坐标
    var circleStop;//停止做圆周运动的清除id;
    var lineStop;//停止做直线运动的id;
    var moveDownIsStop=false;//该变量存储下移动画是否结束
    var linePathIsStop=true;//该变量存储直线运动是否结束
    var circlePathIsStop=false;//该变量存储圆周运动是否结束
    var point=0;
    var Contant={//存储碰撞到障碍物时，障碍物的坐标
      x:0,//获取碰撞障碍物的x坐标
      y:0,//获取碰撞障碍物的y坐标
      startRadian:0,
      result:null,
    }
    var thisHub={//设置一个对象保存当前飞船围绕的中心
      centerX:0,
      centerY:0,
      radian:0,
    }
    canvas.width=winW;
    canvas.height=winH;

    // DrawImg("./img/face.png",'center','center');//绘制封面
    cover.onclick=function(){
      var width=parseInt(getStyle(cover).width);
      var time=setInterval(function(){
        width-=20;
        cover.style.width=width+'px';
        if(width<=20){
          clearInterval(time);
          document.body.removeChild(cover);
          document.body.style.background="white";

        }
      },10);
    }//初始化界面，点击进入游戏界面
    canvas.onclick=function(){//点击canvas开始游戏
      clearInterval(circleStop);
      circlePathIsStop=true;
      console.log("当前直线动画的运行情况"+linePathIsStop)
      console.log("当前圆周动画的运行情况"+circlePathIsStop)
      console.log("当前下移动画的运行情况"+moveDownIsStop)
      //直线动画停止
      //圆周动画正在进行
      //下移动画停止
      if(linePathIsStop&&!moveDownIsStop&&circlePathIsStop){
          LinePath(thisHub.centerX,thisHub.centerY);
      }
    };
    function init(){
     for (var i = 1; i <=count*2;i+=2){//获取固定的y坐标
       var startX=getRandomX();
       var startY=parseInt((winH/(count*2))*i);
       drawCircle(startX,startY,30,'stroke');//绘制
       AllXY.push(startX,startY);
       console.log("x:"+startX+"y:"+startY);
     }
   };//初始化界面的星球障碍物

    var skyBoat={//定义一个飞船对象
      x:AllXY[0]-30,
      y:AllXY[1]-30,
      vx:1,
      vy:1,
      r:5,
      color:"black",
      draw:function(type,centerX,centerY){
          if(!centerX){}
          if(!centerY){}
          switch(type){
            case "line":
              LinePath(skyBoat.x,skyBoat.y,skyBoat);
            break;
            case "circle":
              circlePath(centerX,centerY,skyBoat);
            break;
          }
      }
    }

    init();//点击进去之后初始化图像界面
    drawCircle(skyBoat.x,skyBoat.y,skyBoat.r,'fill');//初始化飞船
    skyBoat.draw("circle",AllXY[AllXY.length-2],AllXY[AllXY.length-1]);//初始化飞船做圆周运动
    function DrawImg(path,imgX,imgY,imgW,imgH){//DrawImg绘制图像的方法
      //DrawImg绘制图像的方法
      //传入的参数有图像的路径--path
      //-----------图像的x坐标-imgX //imgX有left,center,right快速定位的方式
      //-----------图像的y坐标-imgy //imgY有top,center,right快速定位的方式
      //-----------图像的宽度--imgW
      //-----------图像的高度--imgH
      var img=new Image();//创建图像实例
      img.src=path;
      // alert(typeof(imgX));
      if(typeof(imgX)!=="number"){//如果传入的参数不是数字
        if(imgW)img.width=imgW;
        if(imgH)img.height=imgH;
        switch(imgX){
          case "left":imgX=0;
          break;
          case "center":imgX=winW/2-img.width/2;
          break;
          case "right":imgX=winW-img.width;
          break;
          default:console.log("参数错误");
        }
        switch(imgY){
          case "top":imgY=0;
          break;
          case "center":imgY=winH/2-img.height/2;
          break;
          case "bottom":imgY=winH-img.height;
          break;
          default:console.log("参数错误");
        }
      }
      if(!imgX)imgX=imgX;
      if(!imgY)imgY=imgY;
      if(!imgW)imgW=img.width;
      if(!imgH)imgH=img.height;
      img.onload=function(){
        context.drawImage(img,imgX,imgY,imgW,imgH);
      }
    }
    function getStyle(obj){//获取样式的一个方法
      var style=null;
      if(window.getComputedStyle){
        style=window.getComputedStyle(obj,null);
      }else{
        style=obj.currentStyle;
      }
      return style;
    }
    function drawCircle(x,y,r,type){//绘制圆的一个方法
      context.beginPath();
      context.arc(x,y,r,0,2*Math.PI);
      switch(type){
        case "stroke":context.stroke();
        break;
        case "fill":context.fill();
        break;
        default:
        console.log("参数错误");
      }
      context.closePath();
    }
    function LinePath(centerX,centerY){//飞船直线运动的一个方法
      var x3=skyBoat.x;//将skyBoat.x的值暂时保存在x3中
      linePathIsStop=false;
      lineStop=setInterval(function(){
        context.clearRect(0,0,winW,winH);//清除上一个位置的绘制图像
        // centerX=Math.round(centerX);
        // centerY=Math.round(centerY);
        // skyBoat.x=Math.round(skyBoat.x);
        // skyBoat.y=Math.round(skyBoat.y);
        //将坐标转为整数
        if(centerX>skyBoat.x){
          x3-=0.5;
          var y3=drawLinear(skyBoat.x,skyBoat.y,centerX,centerY,x3);
        }
        if(centerX<skyBoat.x){
          x3+=0.5;
          var y3=drawLinear(centerX,centerY,skyBoat.x,skyBoat.y,x3);
        }
        // if(centerX==skyBoat.x){
        //   y3=0;
        // }
        // if(centerY==skyBoat.y){
        //   x3=0;
        // }
        //以上的代码是使飞船做正确的直线运动
        if(x3<0||x3>=winW||y3<0||y3>=winH){
          alert("游戏结束，你穿越了"+point+"星球");
          clearInterval(lineStop);
          linePathIsStop=true;
        }
        //以上代码是判断是都超过边界，超过边界就结束
        var r=isContact(AllXY,x3,y3)//返回一个对象,可以得出是否与障碍产生碰撞
        if(r){
          if(r.result===false){
            skyBoat.x=x3;//发生碰撞时更新skyBoat的x坐标
            skyBoat.y=y3;//发生碰撞时更新skyBoat的y坐标
            clearInterval(lineStop);//如果发生碰撞，就停止直线运动
            linePathIsStop=true;
            clearInterval(circleStop);//如果发生碰撞，就停止圆周运动
            circlePathIsStop=true;
            var c=getDistance(x3,y3,r.x,r.y-30);//算出c边的长
            var cosValue=((30*30)+(30*30)-(c*c))/(2*30*30);//算出c边对应的角度
            if(x3<r.x){//如果落点在圆心的左边，形成的角度是补角，要360-去补角才得出正确的值
              // var nextRadian=360-Math.acos(cosValue)/(2*Math.PI/360);
              Contant.startRadian=360-Math.acos(cosValue)/(2*Math.PI/360);
            }else{//落点在圆心的右边，形成的角是正确的值，不用减去
              // var nextRadian=Math.acos(cosValue)/(2*Math.PI/360);
              Contant.startRadian=Math.acos(cosValue)/(2*Math.PI/360);
            }
            // var lastThisHubCenterY=thisHub.centerY;
            //开始做圆周运动以后，把障碍物下移
            var moveDistance=thisHub.centerY-r.y;
            var moveNum=moveDistance/winH*count;
            moveNum=Math.abs(Math.round(moveNum));
            // moveDownIsStop=false;
            point+=moveNum;//累加分数
            moveDown(moveNum);//下移动画
          }
        }

        drawCircle(x3,y3,skyBoat.r,'fill');//重新绘制飞船的坐标
        drawMap(AllXY);//绘制障碍物
      },5);

    }
    function getRandomX(){//获取到随机x坐标
      return Math.round(Math.random()*(winW-70)+40);
    }
    function circlePath(centerX,centerY,skyBoat,radian){//使飞船做圆周运动
      circlePathIsStop=false;//记录状态是否停止
      thisHub.centerX=centerX;//保存当前飞船围绕的中心坐标X
      thisHub.centerY=centerY;//保存当前飞船围绕的中心坐标Y
      if(!radian){
        var i=0;
      }else{
        var i=radian;
      }
      clearInterval(circleStop);
      circleStop=setInterval(function(){
        // console.log("圆周运动进行中");
        i++;
        if(i>=360)i=0;
          var radian=(2*Math.PI/360)*i;
          thisHub.radian=radian;
          // console.log(radian);
          skyBoat.x=centerX+Math.sin(radian)*30;
          skyBoat.y=centerY-Math.cos(radian)*30;
          clearCircle(centerX,centerY,skyBoat.r);//清除运动物体的位置
          drawCircle(skyBoat.x,skyBoat.y,skyBoat.r,"fill");//绘制运动的物体
          drawCircle(centerX,centerY,30,"stroke");//绘制一个被围绕题
          // console.log(skyBoat.x);
          // console.log(skyBoat.y);
        },10);
      }
    function clearCircle(x,y,r){//清除圆
        context.clearRect(x-30-r,y-30-r,60+r*2,60+r*2);
        //算左上角的坐标思路
        //圆心的x-半径-运动的圆的半径=左上角的X
        //圆心的y-半径-运动的圆的半径=左上角的Y
        //直径+运动圆的直径=结束坐标的x
        //直径+运动圆的直径=结束坐标的y
    }
    function drawMap(AllXY){//绘制地图,就是绘制AllXY数组的所有坐标
      for (var i = 0; i < AllXY.length/2; i++) {
        drawCircle(AllXY[i*2],AllXY[i*2+1],30,"stroke");
      }
    }
    function drawLinear(x1,y1,x2,y2,x3){//根据直线方程推导出来的直线路线
      return (y2-y1)*((x3-x1)/(x2-x1))+y1
    }
    function isContact(AllXY,x,y){//判断是否碰撞
      //传入含有所有障碍物的坐标数组AllXY和飞船的坐标x,y
      //返回值false表示和障碍物碰撞
      var AllXYCopy=[];//设置一个数组来承载筛选过的数组,因为当前的飞船正在围绕一个障碍物做圆周运动，所以要去除当前的障碍物的坐标
      for(var copy=0;copy<AllXY.length/2;copy++){
        if(AllXY[copy*2]!=thisHub.centerX){//
          AllXYCopy.push(AllXY[copy*2]);
        }
        if(AllXY[copy*2+1]!=thisHub.centerY){
          AllXYCopy.push(AllXY[copy*2+1]);
        }
      }
      for(var i=0;i<AllXYCopy.length/2;i++){//
        var Distance=getDistance(AllXYCopy[2*i],AllXYCopy[2*i+1],x,y);//获取每一个障碍物的坐标
         if(Distance<=30){//每一个障碍物和飞船的距离如果比他们之间最小的距离还小，就判定为碰撞
            Contant={
             x:AllXYCopy[2*i],//获取碰撞障碍物的x坐标
             y:AllXYCopy[2*i+1],//获取碰撞障碍物的y坐标
             result:false,
           }
           return Contant;
         }
      }
    }
    function getDistance(x1,y1,x2,y2){//该函数得出两个坐标之间的距离
      var distance=Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
      //通过三角函数可以推导
      return distance;
    }
    function moveDown(num){//使障碍物下移的函数
      var offsetBottom=winH/count;//一次的下移量
      var stopValue=AllXY[1];//保存第一个y坐标
      var roll=2;//滚动的速度
      moveDownIsStop=true;//记录下移动画的状态
      clearInterval(moveDownStop);//每一次进来都清除定时器
      var moveDownStop=setInterval(function(){
        for(var i=0;i<AllXY.length/2;i++){
          if(AllXY[1]>=stopValue+offsetBottom*num){//如果第一个y坐标的坐标超过移动的坐标，停止动画
            clearInterval(moveDownStop);//如果达到指定的下移数，清除定时器
            moveDownIsStop=false;
            AllXY.splice((-2)*num);//因为元素被下移的看不到的地方，所以要清除元素的坐标，清除的数量是传入的数量的2倍，清除的坐标应该是在数组的后面
            // console.log("删除最后元素后"+AllXY+"数组的长度是"+AllXY.length);
            for(var j=0;j<num;j++){//补全数组中因为下移而删除的坐标
              var x=getRandomX();//获取随机x坐标
              var y=AllXY[1]-offsetBottom;//用数组的第一个y坐标减去每一次下移的距离可以得出上一个y坐标的距离，因为y坐标是固定的
              AllXY.unshift(x,y)//将坐标添加到数组的前面
            }
            circlePath(Contant.x,thisHub.centerY,skyBoat,Contant.startRadian);//当下移动画结束的时候,开始执行圆周运动
          }else{//如果没有停止下移动画，那么每次都移动roll/(AllXY.length/2);
                //因为为了与障碍
            skyBoat.y+=roll/(AllXY.length/2);
          }
          AllXY[2*i+1]+=roll;//没有的达到指定的坐标，每一个y坐标不停的加roll;
        }
        context.clearRect(0,0,winW,winH);//清除界面
        drawMap(AllXY);//重新绘制障碍物
        drawCircle(skyBoat.x,skyBoat.y,skyBoat.r,"fill");//更新飞船的位置
      },10);

    }
    function getArrayIndex(arr,inArr){//获取inArr在arr数组中的下标
      for(var i=0;i<arr.length;i++){
        if(arr[i]==inArr){
          return i;
        }
      }
    }
  </script>
</html>
